<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/wprl/baucis">baucis (v1.6.5)</a>
</h1>
<h4>Build scalable REST APIs using the open source tools and standards you already know.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis">module baucis</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.baucis">
            function <span class="apidocSignatureSpan"></span>baucis
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Api">
            function <span class="apidocSignatureSpan">baucis.</span>Api
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Controller">
            function <span class="apidocSignatureSpan">baucis.</span>Controller
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error">
            function <span class="apidocSignatureSpan">baucis.</span>Error
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadRequest">
            function <span class="apidocSignatureSpan">baucis.</span>Error.BadRequest
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadSyntax">
            function <span class="apidocSignatureSpan">baucis.</span>Error.BadSyntax
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Deprecated">
            function <span class="apidocSignatureSpan">baucis.</span>Error.Deprecated
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Forbidden">
            function <span class="apidocSignatureSpan">baucis.</span>Error.Forbidden
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Gone">
            function <span class="apidocSignatureSpan">baucis.</span>Error.Gone
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.InternalServerError">
            function <span class="apidocSignatureSpan">baucis.</span>Error.InternalServerError
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LengthRequired">
            function <span class="apidocSignatureSpan">baucis.</span>Error.LengthRequired
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LockConflict">
            function <span class="apidocSignatureSpan">baucis.</span>Error.LockConflict
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.MethodNotAllowed">
            function <span class="apidocSignatureSpan">baucis.</span>Error.MethodNotAllowed
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Misconfigured">
            function <span class="apidocSignatureSpan">baucis.</span>Error.Misconfigured
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotAcceptable">
            function <span class="apidocSignatureSpan">baucis.</span>Error.NotAcceptable
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotFound">
            function <span class="apidocSignatureSpan">baucis.</span>Error.NotFound
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotImplemented">
            function <span class="apidocSignatureSpan">baucis.</span>Error.NotImplemented
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.PreconditionFailed">
            function <span class="apidocSignatureSpan">baucis.</span>Error.PreconditionFailed
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestEntityTooLarge">
            function <span class="apidocSignatureSpan">baucis.</span>Error.RequestEntityTooLarge
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestUriTooLong">
            function <span class="apidocSignatureSpan">baucis.</span>Error.RequestUriTooLong
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Teapot">
            function <span class="apidocSignatureSpan">baucis.</span>Error.Teapot
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.TooManyRequests">
            function <span class="apidocSignatureSpan">baucis.</span>Error.TooManyRequests
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Unauthorized">
            function <span class="apidocSignatureSpan">baucis.</span>Error.Unauthorized
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnprocessableEntity">
            function <span class="apidocSignatureSpan">baucis.</span>Error.UnprocessableEntity
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnsupportedMediaType">
            function <span class="apidocSignatureSpan">baucis.</span>Error.UnsupportedMediaType
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.super_">
            function <span class="apidocSignatureSpan">baucis.</span>Error.super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Model">
            function <span class="apidocSignatureSpan">baucis.</span>Model
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.empty">
            function <span class="apidocSignatureSpan">baucis.</span>empty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.formatters">
            function <span class="apidocSignatureSpan">baucis.</span>formatters
            <span class="apidocSignatureSpan">(response, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.parser">
            function <span class="apidocSignatureSpan">baucis.</span>parser
            <span class="apidocSignatureSpan">(mime, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.rest">
            function <span class="apidocSignatureSpan">baucis.</span>rest
            <span class="apidocSignatureSpan">(model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.setFormatter">
            function <span class="apidocSignatureSpan">baucis.</span>setFormatter
            <span class="apidocSignatureSpan">(mime, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.setParser">
            function <span class="apidocSignatureSpan">baucis.</span>setParser
            <span class="apidocSignatureSpan">(mime, f)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">baucis.</span>Error.UnprocessableEntity.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Api">module baucis.Api</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Api.Api">
            function <span class="apidocSignatureSpan">baucis.</span>Api
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Api.container">
            function <span class="apidocSignatureSpan">baucis.Api.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Api.decorators">
            function <span class="apidocSignatureSpan">baucis.Api.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Api.defaults">
            function <span class="apidocSignatureSpan">baucis.Api.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Api.factory">
            function <span class="apidocSignatureSpan">baucis.Api.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Api.inherit">
            function <span class="apidocSignatureSpan">baucis.Api.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Api.sanitize">
            function <span class="apidocSignatureSpan">baucis.Api.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Controller">module baucis.Controller</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Controller.Controller">
            function <span class="apidocSignatureSpan">baucis.</span>Controller
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Controller.container">
            function <span class="apidocSignatureSpan">baucis.Controller.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Controller.decorators">
            function <span class="apidocSignatureSpan">baucis.Controller.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Controller.defaults">
            function <span class="apidocSignatureSpan">baucis.Controller.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Controller.factory">
            function <span class="apidocSignatureSpan">baucis.Controller.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Controller.inherit">
            function <span class="apidocSignatureSpan">baucis.Controller.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Controller.sanitize">
            function <span class="apidocSignatureSpan">baucis.Controller.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error">module baucis.Error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Error">
            function <span class="apidocSignatureSpan">baucis.</span>Error
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadRequest">
            function <span class="apidocSignatureSpan">baucis.Error.</span>BadRequest
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadSyntax">
            function <span class="apidocSignatureSpan">baucis.Error.</span>BadSyntax
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Deprecated">
            function <span class="apidocSignatureSpan">baucis.Error.</span>Deprecated
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Forbidden">
            function <span class="apidocSignatureSpan">baucis.Error.</span>Forbidden
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Gone">
            function <span class="apidocSignatureSpan">baucis.Error.</span>Gone
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.InternalServerError">
            function <span class="apidocSignatureSpan">baucis.Error.</span>InternalServerError
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LengthRequired">
            function <span class="apidocSignatureSpan">baucis.Error.</span>LengthRequired
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LockConflict">
            function <span class="apidocSignatureSpan">baucis.Error.</span>LockConflict
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.MethodNotAllowed">
            function <span class="apidocSignatureSpan">baucis.Error.</span>MethodNotAllowed
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Misconfigured">
            function <span class="apidocSignatureSpan">baucis.Error.</span>Misconfigured
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotAcceptable">
            function <span class="apidocSignatureSpan">baucis.Error.</span>NotAcceptable
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotFound">
            function <span class="apidocSignatureSpan">baucis.Error.</span>NotFound
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotImplemented">
            function <span class="apidocSignatureSpan">baucis.Error.</span>NotImplemented
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.PreconditionFailed">
            function <span class="apidocSignatureSpan">baucis.Error.</span>PreconditionFailed
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestEntityTooLarge">
            function <span class="apidocSignatureSpan">baucis.Error.</span>RequestEntityTooLarge
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestUriTooLong">
            function <span class="apidocSignatureSpan">baucis.Error.</span>RequestUriTooLong
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Teapot">
            function <span class="apidocSignatureSpan">baucis.Error.</span>Teapot
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.TooManyRequests">
            function <span class="apidocSignatureSpan">baucis.Error.</span>TooManyRequests
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Unauthorized">
            function <span class="apidocSignatureSpan">baucis.Error.</span>Unauthorized
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnprocessableEntity">
            function <span class="apidocSignatureSpan">baucis.Error.</span>UnprocessableEntity
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnsupportedMediaType">
            function <span class="apidocSignatureSpan">baucis.Error.</span>UnsupportedMediaType
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.container">
            function <span class="apidocSignatureSpan">baucis.Error.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.factory">
            function <span class="apidocSignatureSpan">baucis.Error.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.status">
            function <span class="apidocSignatureSpan">baucis.Error.</span>status
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.super_">
            function <span class="apidocSignatureSpan">baucis.Error.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.BadRequest">module baucis.Error.BadRequest</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadRequest.BadRequest">
            function <span class="apidocSignatureSpan">baucis.Error.</span>BadRequest
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadRequest.container">
            function <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadRequest.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadRequest.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadRequest.factory">
            function <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadRequest.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadRequest.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadRequest.super_">
            function <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.BadSyntax">module baucis.Error.BadSyntax</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadSyntax.BadSyntax">
            function <span class="apidocSignatureSpan">baucis.Error.</span>BadSyntax
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadSyntax.container">
            function <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadSyntax.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadSyntax.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadSyntax.factory">
            function <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadSyntax.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadSyntax.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.BadSyntax.super_">
            function <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.Deprecated">module baucis.Error.Deprecated</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Deprecated.Deprecated">
            function <span class="apidocSignatureSpan">baucis.Error.</span>Deprecated
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Deprecated.container">
            function <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Deprecated.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Deprecated.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Deprecated.factory">
            function <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Deprecated.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Deprecated.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Deprecated.super_">
            function <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.Forbidden">module baucis.Error.Forbidden</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Forbidden.Forbidden">
            function <span class="apidocSignatureSpan">baucis.Error.</span>Forbidden
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Forbidden.container">
            function <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Forbidden.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Forbidden.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Forbidden.factory">
            function <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Forbidden.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Forbidden.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Forbidden.super_">
            function <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.Gone">module baucis.Error.Gone</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Gone.Gone">
            function <span class="apidocSignatureSpan">baucis.Error.</span>Gone
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Gone.container">
            function <span class="apidocSignatureSpan">baucis.Error.Gone.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Gone.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.Gone.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Gone.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.Gone.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Gone.factory">
            function <span class="apidocSignatureSpan">baucis.Error.Gone.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Gone.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.Gone.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Gone.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.Gone.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Gone.super_">
            function <span class="apidocSignatureSpan">baucis.Error.Gone.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.Gone.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.InternalServerError">module baucis.Error.InternalServerError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.InternalServerError.InternalServerError">
            function <span class="apidocSignatureSpan">baucis.Error.</span>InternalServerError
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.InternalServerError.container">
            function <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.InternalServerError.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.InternalServerError.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.InternalServerError.factory">
            function <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.InternalServerError.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.InternalServerError.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.InternalServerError.super_">
            function <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.LengthRequired">module baucis.Error.LengthRequired</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LengthRequired.LengthRequired">
            function <span class="apidocSignatureSpan">baucis.Error.</span>LengthRequired
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LengthRequired.container">
            function <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LengthRequired.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LengthRequired.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LengthRequired.factory">
            function <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LengthRequired.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LengthRequired.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LengthRequired.super_">
            function <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.LockConflict">module baucis.Error.LockConflict</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LockConflict.LockConflict">
            function <span class="apidocSignatureSpan">baucis.Error.</span>LockConflict
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LockConflict.container">
            function <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LockConflict.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LockConflict.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LockConflict.factory">
            function <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LockConflict.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LockConflict.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.LockConflict.super_">
            function <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.MethodNotAllowed">module baucis.Error.MethodNotAllowed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.MethodNotAllowed.MethodNotAllowed">
            function <span class="apidocSignatureSpan">baucis.Error.</span>MethodNotAllowed
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.MethodNotAllowed.container">
            function <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.MethodNotAllowed.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.MethodNotAllowed.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.MethodNotAllowed.factory">
            function <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.MethodNotAllowed.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.MethodNotAllowed.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.MethodNotAllowed.super_">
            function <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.Misconfigured">module baucis.Error.Misconfigured</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Misconfigured.Misconfigured">
            function <span class="apidocSignatureSpan">baucis.Error.</span>Misconfigured
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Misconfigured.container">
            function <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Misconfigured.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Misconfigured.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Misconfigured.factory">
            function <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Misconfigured.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Misconfigured.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Misconfigured.super_">
            function <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.NotAcceptable">module baucis.Error.NotAcceptable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotAcceptable.NotAcceptable">
            function <span class="apidocSignatureSpan">baucis.Error.</span>NotAcceptable
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotAcceptable.container">
            function <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotAcceptable.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotAcceptable.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotAcceptable.factory">
            function <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotAcceptable.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotAcceptable.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotAcceptable.super_">
            function <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.NotFound">module baucis.Error.NotFound</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotFound.NotFound">
            function <span class="apidocSignatureSpan">baucis.Error.</span>NotFound
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotFound.container">
            function <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotFound.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotFound.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotFound.factory">
            function <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotFound.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotFound.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotFound.super_">
            function <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.NotImplemented">module baucis.Error.NotImplemented</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotImplemented.NotImplemented">
            function <span class="apidocSignatureSpan">baucis.Error.</span>NotImplemented
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotImplemented.container">
            function <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotImplemented.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotImplemented.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotImplemented.factory">
            function <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotImplemented.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotImplemented.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.NotImplemented.super_">
            function <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.PreconditionFailed">module baucis.Error.PreconditionFailed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.PreconditionFailed.PreconditionFailed">
            function <span class="apidocSignatureSpan">baucis.Error.</span>PreconditionFailed
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.PreconditionFailed.container">
            function <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.PreconditionFailed.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.PreconditionFailed.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.PreconditionFailed.factory">
            function <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.PreconditionFailed.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.PreconditionFailed.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.PreconditionFailed.super_">
            function <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.RequestEntityTooLarge">module baucis.Error.RequestEntityTooLarge</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestEntityTooLarge.RequestEntityTooLarge">
            function <span class="apidocSignatureSpan">baucis.Error.</span>RequestEntityTooLarge
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestEntityTooLarge.container">
            function <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestEntityTooLarge.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestEntityTooLarge.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestEntityTooLarge.factory">
            function <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestEntityTooLarge.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestEntityTooLarge.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestEntityTooLarge.super_">
            function <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.RequestUriTooLong">module baucis.Error.RequestUriTooLong</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestUriTooLong.RequestUriTooLong">
            function <span class="apidocSignatureSpan">baucis.Error.</span>RequestUriTooLong
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestUriTooLong.container">
            function <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestUriTooLong.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestUriTooLong.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestUriTooLong.factory">
            function <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestUriTooLong.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestUriTooLong.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.RequestUriTooLong.super_">
            function <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.Teapot">module baucis.Error.Teapot</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Teapot.Teapot">
            function <span class="apidocSignatureSpan">baucis.Error.</span>Teapot
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Teapot.container">
            function <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Teapot.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Teapot.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Teapot.factory">
            function <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Teapot.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Teapot.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Teapot.super_">
            function <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.TooManyRequests">module baucis.Error.TooManyRequests</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.TooManyRequests.TooManyRequests">
            function <span class="apidocSignatureSpan">baucis.Error.</span>TooManyRequests
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.TooManyRequests.container">
            function <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.TooManyRequests.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.TooManyRequests.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.TooManyRequests.factory">
            function <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.TooManyRequests.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.TooManyRequests.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.TooManyRequests.super_">
            function <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.Unauthorized">module baucis.Error.Unauthorized</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Unauthorized.Unauthorized">
            function <span class="apidocSignatureSpan">baucis.Error.</span>Unauthorized
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Unauthorized.container">
            function <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Unauthorized.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Unauthorized.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Unauthorized.factory">
            function <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Unauthorized.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Unauthorized.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.Unauthorized.super_">
            function <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.UnprocessableEntity">module baucis.Error.UnprocessableEntity</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnprocessableEntity.UnprocessableEntity">
            function <span class="apidocSignatureSpan">baucis.Error.</span>UnprocessableEntity
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnprocessableEntity.container">
            function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnprocessableEntity.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnprocessableEntity.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnprocessableEntity.factory">
            function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnprocessableEntity.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnprocessableEntity.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnprocessableEntity.super_">
            function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.UnprocessableEntity.prototype">module baucis.Error.UnprocessableEntity.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnprocessableEntity.prototype.add">
            function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.prototype.</span>add
            <span class="apidocSignatureSpan">(key, error)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.UnsupportedMediaType">module baucis.Error.UnsupportedMediaType</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnsupportedMediaType.UnsupportedMediaType">
            function <span class="apidocSignatureSpan">baucis.Error.</span>UnsupportedMediaType
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnsupportedMediaType.container">
            function <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnsupportedMediaType.decorators">
            function <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnsupportedMediaType.defaults">
            function <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnsupportedMediaType.factory">
            function <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnsupportedMediaType.inherit">
            function <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnsupportedMediaType.sanitize">
            function <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.UnsupportedMediaType.super_">
            function <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>super_
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>status</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Error.super_">module baucis.Error.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.super_.super_">
            function <span class="apidocSignatureSpan">baucis.Error.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Error.super_.captureStackTrace">
            function <span class="apidocSignatureSpan">baucis.Error.super_.</span>captureStackTrace
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">baucis.Error.super_.</span>stackTraceLimit</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.baucis.Model">module baucis.Model</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Model.Model">
            function <span class="apidocSignatureSpan">baucis.</span>Model
            <span class="apidocSignatureSpan">(incoming, protect)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Model.container">
            function <span class="apidocSignatureSpan">baucis.Model.</span>container
            <span class="apidocSignatureSpan">(container)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Model.decorators">
            function <span class="apidocSignatureSpan">baucis.Model.</span>decorators
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Model.defaults">
            function <span class="apidocSignatureSpan">baucis.Model.</span>defaults
            <span class="apidocSignatureSpan">(incoming)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Model.factory">
            function <span class="apidocSignatureSpan">baucis.Model.</span>factory
            <span class="apidocSignatureSpan">(factory)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Model.inherit">
            function <span class="apidocSignatureSpan">baucis.Model.</span>inherit
            <span class="apidocSignatureSpan">(super_)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.baucis.Model.sanitize">
            function <span class="apidocSignatureSpan">baucis.Model.</span>sanitize
            <span class="apidocSignatureSpan">(f)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis" id="apidoc.module.baucis">module baucis</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.baucis" id="apidoc.element.baucis.baucis">
        function <span class="apidocSignatureSpan"></span>baucis
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">baucis = function (options) {
  return baucis.empty();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var vegetables = new Vegetables();
var tomato = new Vegetable({ _id: 'abcdabcdabcdabcd' });
var potato = new Vegetable({ name: 'Potato' });

// Make some requests and print out the results

// Fetch red vegetables, setting a few options
vegetables.<span class="apidocCodeKeywordSpan">baucis</span>(
  {
    conditions: { color: 'red' },
    populate: 'child',
    skip: 20,
    limit: 10,
    sort: 'foo -bar'
  },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Api" id="apidoc.element.baucis.Api">
        function <span class="apidocSignatureSpan">baucis.</span>Api
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Api = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Controller" id="apidoc.element.baucis.Controller">
        function <span class="apidocSignatureSpan">baucis.</span>Controller
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Controller = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
after(fixtures.controller.deinit);

it('should allow passing string name to create', function (done) {
  var makeController = function () { baucis.<span class="apidocCodeKeywordSpan">Controller</span>('unmade') };
  makeController();
  expect(makeController).to.not.throwException();
  done();
});

it('should allow passing a model to create', function (done) {
  var makeController = function () { baucis.Controller(mongoose.model('unmade')) };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error" id="apidoc.element.baucis.Error">
        function <span class="apidocSignatureSpan">baucis.</span>Error
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadRequest" id="apidoc.element.baucis.Error.BadRequest">
        function <span class="apidocSignatureSpan">baucis.</span>Error.BadRequest
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.BadRequest = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadSyntax" id="apidoc.element.baucis.Error.BadSyntax">
        function <span class="apidocSignatureSpan">baucis.</span>Error.BadSyntax
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.BadSyntax = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Deprecated" id="apidoc.element.baucis.Error.Deprecated">
        function <span class="apidocSignatureSpan">baucis.</span>Error.Deprecated
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.Deprecated = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Forbidden" id="apidoc.element.baucis.Error.Forbidden">
        function <span class="apidocSignatureSpan">baucis.</span>Error.Forbidden
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.Forbidden = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  request.baucis.query.select('_id lastModified');
  next();
});

veggies.request(function (request, response, next) {
  if (request.query.failIt !== 'true') return next();
  request.baucis.incoming(es.through(function (context) {
    this.emit('error', baucis.<span class="apidocCodeKeywordSpan">Error.Forbidden</span>('Bento box'));
  }));
  next();
});

veggies.request(function (request, response, next) {
  if (request.query.failItFunction !== 'true') return next();
  request.baucis.incoming(function (context, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Gone" id="apidoc.element.baucis.Error.Gone">
        function <span class="apidocSignatureSpan">baucis.</span>Error.Gone
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.Gone = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.InternalServerError" id="apidoc.element.baucis.Error.InternalServerError">
        function <span class="apidocSignatureSpan">baucis.</span>Error.InternalServerError
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.InternalServerError = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LengthRequired" id="apidoc.element.baucis.Error.LengthRequired">
        function <span class="apidocSignatureSpan">baucis.</span>Error.LengthRequired
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.LengthRequired = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LockConflict" id="apidoc.element.baucis.Error.LockConflict">
        function <span class="apidocSignatureSpan">baucis.</span>Error.LockConflict
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.LockConflict = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.MethodNotAllowed" id="apidoc.element.baucis.Error.MethodNotAllowed">
        function <span class="apidocSignatureSpan">baucis.</span>Error.MethodNotAllowed
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.MethodNotAllowed = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Misconfigured" id="apidoc.element.baucis.Error.Misconfigured">
        function <span class="apidocSignatureSpan">baucis.</span>Error.Misconfigured
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.Misconfigured = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotAcceptable" id="apidoc.element.baucis.Error.NotAcceptable">
        function <span class="apidocSignatureSpan">baucis.</span>Error.NotAcceptable
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.NotAcceptable = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotFound" id="apidoc.element.baucis.Error.NotFound">
        function <span class="apidocSignatureSpan">baucis.</span>Error.NotFound
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.NotFound = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotImplemented" id="apidoc.element.baucis.Error.NotImplemented">
        function <span class="apidocSignatureSpan">baucis.</span>Error.NotImplemented
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.NotImplemented = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.PreconditionFailed" id="apidoc.element.baucis.Error.PreconditionFailed">
        function <span class="apidocSignatureSpan">baucis.</span>Error.PreconditionFailed
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.PreconditionFailed = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestEntityTooLarge" id="apidoc.element.baucis.Error.RequestEntityTooLarge">
        function <span class="apidocSignatureSpan">baucis.</span>Error.RequestEntityTooLarge
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.RequestEntityTooLarge = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestUriTooLong" id="apidoc.element.baucis.Error.RequestUriTooLong">
        function <span class="apidocSignatureSpan">baucis.</span>Error.RequestUriTooLong
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.RequestUriTooLong = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Teapot" id="apidoc.element.baucis.Error.Teapot">
        function <span class="apidocSignatureSpan">baucis.</span>Error.Teapot
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.Teapot = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.TooManyRequests" id="apidoc.element.baucis.Error.TooManyRequests">
        function <span class="apidocSignatureSpan">baucis.</span>Error.TooManyRequests
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.TooManyRequests = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Unauthorized" id="apidoc.element.baucis.Error.Unauthorized">
        function <span class="apidocSignatureSpan">baucis.</span>Error.Unauthorized
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.Unauthorized = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnprocessableEntity" id="apidoc.element.baucis.Error.UnprocessableEntity">
        function <span class="apidocSignatureSpan">baucis.</span>Error.UnprocessableEntity
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.UnprocessableEntity = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnsupportedMediaType" id="apidoc.element.baucis.Error.UnsupportedMediaType">
        function <span class="apidocSignatureSpan">baucis.</span>Error.UnsupportedMediaType
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error.UnsupportedMediaType = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.super_" id="apidoc.element.baucis.Error.super_">
        function <span class="apidocSignatureSpan">baucis.</span>Error.super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Model" id="apidoc.element.baucis.Model">
        function <span class="apidocSignatureSpan">baucis.</span>Model
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Model = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.empty" id="apidoc.element.baucis.empty">
        function <span class="apidocSignatureSpan">baucis.</span>empty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">empty = function () {
  var previous = instance;
  instance = Api();
  return previous;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var instance;
var parsers = {};
var formatters = {};
var errorFormatters = {};

// __Module Definition__
var baucis = module.exports = function (options) {
  return baucis.<span class="apidocCodeKeywordSpan">empty</span>();
};

// __Public Members__
baucis.rest = function (model) {
  if (!instance) instance = Api();
  return instance.rest(model);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.formatters" id="apidoc.element.baucis.formatters">
        function <span class="apidocSignatureSpan">baucis.</span>formatters
        <span class="apidocSignatureSpan">(response, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatters = function (response, callback) {
  // if (response._headerSent) {
  //   callback(null, function () {
  //     return es.through(function (data) { console.log(data) }, function () {
  //       this.emit('end');
  //     });
  //   });
  //   return;
  // }

  var handlers = {
    default: function () {
      callback(RestError.NotAcceptable());
    }
  };

  Object.keys(formatters).map(function (mime) {
    handlers[mime] = formatters[mime](callback);
  });
  response.format(handlers);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // Always set the status code if available.
    if (error.status &gt;= 100) {
response.status(error.status);
    }

    if (!controller.handleErrors()) return next(error);

    baucis.<span class="apidocCodeKeywordSpan">formatters</span>(response, function (error2, formatter) {
if (error2) return next(error2);

var errors;

if (!error.errors) {
  errors = [error];
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.parser" id="apidoc.element.baucis.parser">
        function <span class="apidocSignatureSpan">baucis.</span>parser
        <span class="apidocSignatureSpan">(mime, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parser = function (mime, handler) {
  // Default to JSON when no MIME type is provided.
  mime = mime || 'application/json';
  // Not interested in any additional parameters at this point.
  mime = mime.split(';')[0].trim();
  var handler = parsers[mime];
  return handler ? handler() : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Check if the body was parsed by some external middleware e.g. `express.json`.
// If so, create a stream from the POST'd document or documents.
if (request.body) {
  pipeline(es.readArray([].concat(request.body)));
}
// Otherwise, stream and parse the request.
else {
  parser = baucis.<span class="apidocCodeKeywordSpan">parser</span>(request.get('content-type'));
  if (!parser) return next(RestError.UnsupportedMediaType());
  pipeline(request);
  pipeline(parser);
}
// Create the stream context.
pipeline(function (incoming, callback) {
  callback(null, { incoming: incoming, doc: null });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.rest" id="apidoc.element.baucis.rest">
        function <span class="apidocSignatureSpan">baucis.</span>rest
        <span class="apidocSignatureSpan">(model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rest = function (model) {
  if (!instance) instance = Api();
  return instance.rest(model);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Add custom API definitions to a controller with `controller.addSwaggerApi`.  Other minor Swagger fixes.


## v0.7.0

Add support for hint and comment.  Enable them like so:

    baucis.<span class="apidocCodeKeywordSpan">rest</span>({
      singular: 'fish',
      'allow hints': true,
      'allow comments': true
    });

Note: I decided to be more strict with implementing semver.  Minor version will be increasing with each new feature and patch number
 will be increased with bug fixes and misc. patches.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.setFormatter" id="apidoc.element.baucis.setFormatter">
        function <span class="apidocSignatureSpan">baucis.</span>setFormatter
        <span class="apidocSignatureSpan">(mime, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setFormatter = function (mime, f) {
  formatters[mime] = function (callback) { return function () { callback(null, f) } };
  return baucis;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.setParser" id="apidoc.element.baucis.setParser">
        function <span class="apidocSignatureSpan">baucis.</span>setParser
        <span class="apidocSignatureSpan">(mime, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setParser = function (mime, f) {
  parsers[mime] = f;
  return baucis;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Api" id="apidoc.module.baucis.Api">module baucis.Api</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Api.Api" id="apidoc.element.baucis.Api.Api">
        function <span class="apidocSignatureSpan">baucis.</span>Api
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Api = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Api.container" id="apidoc.element.baucis.Api.container">
        function <span class="apidocSignatureSpan">baucis.Api.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Api.decorators" id="apidoc.element.baucis.Api.decorators">
        function <span class="apidocSignatureSpan">baucis.Api.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Api.defaults" id="apidoc.element.baucis.Api.defaults">
        function <span class="apidocSignatureSpan">baucis.Api.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Api.factory" id="apidoc.element.baucis.Api.factory">
        function <span class="apidocSignatureSpan">baucis.Api.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Api.inherit" id="apidoc.element.baucis.Api.inherit">
        function <span class="apidocSignatureSpan">baucis.Api.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Api.sanitize" id="apidoc.element.baucis.Api.sanitize">
        function <span class="apidocSignatureSpan">baucis.Api.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Controller" id="apidoc.module.baucis.Controller">module baucis.Controller</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Controller.Controller" id="apidoc.element.baucis.Controller.Controller">
        function <span class="apidocSignatureSpan">baucis.</span>Controller
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Controller = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
after(fixtures.controller.deinit);

it('should allow passing string name to create', function (done) {
  var makeController = function () { baucis.<span class="apidocCodeKeywordSpan">Controller</span>('unmade') };
  makeController();
  expect(makeController).to.not.throwException();
  done();
});

it('should allow passing a model to create', function (done) {
  var makeController = function () { baucis.Controller(mongoose.model('unmade')) };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Controller.container" id="apidoc.element.baucis.Controller.container">
        function <span class="apidocSignatureSpan">baucis.Controller.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Controller.decorators" id="apidoc.element.baucis.Controller.decorators">
        function <span class="apidocSignatureSpan">baucis.Controller.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Controller.defaults" id="apidoc.element.baucis.Controller.defaults">
        function <span class="apidocSignatureSpan">baucis.Controller.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Controller.factory" id="apidoc.element.baucis.Controller.factory">
        function <span class="apidocSignatureSpan">baucis.Controller.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Controller.inherit" id="apidoc.element.baucis.Controller.inherit">
        function <span class="apidocSignatureSpan">baucis.Controller.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Controller.sanitize" id="apidoc.element.baucis.Controller.sanitize">
        function <span class="apidocSignatureSpan">baucis.Controller.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error" id="apidoc.module.baucis.Error">module baucis.Error</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.Error" id="apidoc.element.baucis.Error.Error">
        function <span class="apidocSignatureSpan">baucis.</span>Error
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Error = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadRequest" id="apidoc.element.baucis.Error.BadRequest">
        function <span class="apidocSignatureSpan">baucis.Error.</span>BadRequest
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BadRequest = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
response.vary('API-Version');
// TODO move this
// Requested range is used to select highest possible release number.
// Then later controllers are checked for matching the release number.
var version = request.headers['api-version'] || '*';
// Check the requested API version is valid.
if (!semver.validRange(version)) {
  next(RestError.<span class="apidocCodeKeywordSpan">BadRequest</span>('The requested API version range "%s" was
not a valid semver range', version));
  return;
}

request.baucis.release = semver.maxSatisfying(api.releases(), version);
// Check for API version unsatisfied and give a 400 if no versions match.
if (!request.baucis.release) {
  next(RestError.BadRequest('The requested API version range "%s" could not be satisfied', version));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadSyntax" id="apidoc.element.baucis.Error.BadSyntax">
        function <span class="apidocSignatureSpan">baucis.Error.</span>BadSyntax
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BadSyntax = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Deprecated" id="apidoc.element.baucis.Error.Deprecated">
        function <span class="apidocSignatureSpan">baucis.Error.</span>Deprecated
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Deprecated = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Forbidden" id="apidoc.element.baucis.Error.Forbidden">
        function <span class="apidocSignatureSpan">baucis.Error.</span>Forbidden
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Forbidden = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Perform distinct query.
this.query(function (request, response, next) {
  var distinct = request.query.distinct;
  if (!distinct) return next();
  if (controller.deselected(distinct)) {
    next(RestError.<span class="apidocCodeKeywordSpan">Forbidden</span>('You may not find distinct values for the requested
 path'));
    return;
  }
  var query = controller.model().distinct(distinct, request.baucis.conditions);
  query.exec(function (error, values) {
    if (error) return next(error);
    request.baucis.documents = values;
    next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Gone" id="apidoc.element.baucis.Error.Gone">
        function <span class="apidocSignatureSpan">baucis.Error.</span>Gone
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Gone = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.InternalServerError" id="apidoc.element.baucis.Error.InternalServerError">
        function <span class="apidocSignatureSpan">baucis.Error.</span>InternalServerError
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">InternalServerError = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!(error instanceof mongoose.Error.VersionError)) return next(error);
  next(RestError.LockConflict());
});
// Translate other errors to internal server errors.
protect.use(function (error, request, response, next) {
  if (!error) return next();
  if (error instanceof RestError) return next(error);
  var error2 = RestError.<span class="apidocCodeKeywordSpan">InternalServerError</span>(error.message);
  error2.stack = error.stack;
  next(error2);
});
// Format the error based on the Accept header.
protect.use(function (error, request, response, next) {
  if (!error) return next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LengthRequired" id="apidoc.element.baucis.Error.LengthRequired">
        function <span class="apidocSignatureSpan">baucis.Error.</span>LengthRequired
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LengthRequired = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LockConflict" id="apidoc.element.baucis.Error.LockConflict">
        function <span class="apidocSignatureSpan">baucis.Error.</span>LockConflict
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LockConflict = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  newError.errors = error.errors;
  next(newError);
});
// Convert Mongoose version conflict error to LockConflict.
protect.use(function (error, request, response, next) {
  if (!error) return next();
  if (!(error instanceof mongoose.Error.VersionError)) return next(error);
  next(RestError.<span class="apidocCodeKeywordSpan">LockConflict</span>());
});
// Translate other errors to internal server errors.
protect.use(function (error, request, response, next) {
  if (!error) return next();
  if (error instanceof RestError) return next(error);
  var error2 = RestError.InternalServerError(error.message);
  error2.stack = error.stack;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.MethodNotAllowed" id="apidoc.element.baucis.Error.MethodNotAllowed">
        function <span class="apidocSignatureSpan">baucis.Error.</span>MethodNotAllowed
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MethodNotAllowed = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  next(RestError.BadRequest('The requested document ID "%s" is not a valid document ID', id));
});

// Check that the HTTP method has not been disabled for this controller.
controller.request(function (request, response, next) {
  var method = request.method.toLowerCase();
  if (controller.methods(method) !== false) return next();
  next(RestError.<span class="apidocCodeKeywordSpan">MethodNotAllowed</span>('The requested method has been disabled for this
 resource'));
});

// Treat the addressed document as a collection, and push the addressed object
// to it.  (Not implemented.)
controller.request('instance', 'post', function (request, response, next) {
  return next(RestError.NotImplemented('Cannot POST to an instance'));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Misconfigured" id="apidoc.element.baucis.Error.Misconfigured">
        function <span class="apidocSignatureSpan">baucis.Error.</span>Misconfigured
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Misconfigured = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var RestError = require('rest-error');

// __Module Definition__
var Api = module.exports = deco(function (options, protect) {
  var api = this;

  api.use(function (request, response, next) {
if (request.baucis) return next(RestError.<span class="apidocCodeKeywordSpan">Misconfigured</span>('Baucis request property
 already created'));

request.baucis = {};
response.removeHeader('x-powered-by');
// Any caching proxies should be aware of API version.
response.vary('API-Version');
// TODO move this
// Requested range is used to select highest possible release number.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotAcceptable" id="apidoc.element.baucis.Error.NotAcceptable">
        function <span class="apidocSignatureSpan">baucis.Error.</span>NotAcceptable
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotAcceptable = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//     });
//   });
//   return;
// }

var handlers = {
  default: function () {
    callback(RestError.<span class="apidocCodeKeywordSpan">NotAcceptable</span>());
  }
};

Object.keys(formatters).map(function (mime) {
  handlers[mime] = formatters[mime](callback);
});
response.format(handlers);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotFound" id="apidoc.element.baucis.Error.NotFound">
        function <span class="apidocSignatureSpan">baucis.Error.</span>NotFound
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotFound = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (status === 200) {
      response.removeHeader('Transfer-Encoding');
      response.json([]); // TODO other content types
      this.emit('end');
      return;
    }

    this.emit('error', RestError.<span class="apidocCodeKeywordSpan">NotFound</span>());
  }
));
// Apply user streams.
pipeline(request.baucis.outgoing());

// Set the document formatter based on the Accept header of the request.
baucis.formatters(response, function (error, formatter) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotImplemented" id="apidoc.element.baucis.Error.NotImplemented">
        function <span class="apidocSignatureSpan">baucis.Error.</span>NotImplemented
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotImplemented = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    // Finish up for a non-default update operator (bypasses validation).
    else {
      pipeline(function (context, callback) {
var wrapper = {};

if (validOperators.indexOf(operator) === -1) {
  callback(RestError.<span class="apidocCodeKeywordSpan">NotImplemented</span>('The requested update operator "%s"
; is not supported', operator));
  return;
}
// Ensure that some paths have been enabled for the operator.
if (!controller.operators(operator)) {
  callback(RestError.Forbidden('The requested update operator "%s" is not enabled for this resource', operator
));
  return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.PreconditionFailed" id="apidoc.element.baucis.Error.PreconditionFailed">
        function <span class="apidocSignatureSpan">baucis.Error.</span>PreconditionFailed
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PreconditionFailed = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestEntityTooLarge" id="apidoc.element.baucis.Error.RequestEntityTooLarge">
        function <span class="apidocSignatureSpan">baucis.Error.</span>RequestEntityTooLarge
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RequestEntityTooLarge = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestUriTooLong" id="apidoc.element.baucis.Error.RequestUriTooLong">
        function <span class="apidocSignatureSpan">baucis.Error.</span>RequestUriTooLong
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RequestUriTooLong = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Teapot" id="apidoc.element.baucis.Error.Teapot">
        function <span class="apidocSignatureSpan">baucis.Error.</span>Teapot
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Teapot = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.TooManyRequests" id="apidoc.element.baucis.Error.TooManyRequests">
        function <span class="apidocSignatureSpan">baucis.Error.</span>TooManyRequests
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TooManyRequests = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Unauthorized" id="apidoc.element.baucis.Error.Unauthorized">
        function <span class="apidocSignatureSpan">baucis.Error.</span>Unauthorized
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Unauthorized = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnprocessableEntity" id="apidoc.element.baucis.Error.UnprocessableEntity">
        function <span class="apidocSignatureSpan">baucis.Error.</span>UnprocessableEntity
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UnprocessableEntity = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    originalMessage: error.message,
    name: 'MongoError',
    path: path,
    type: 'unique',
    value: value
  };

  var translatedError = RestError.<span class="apidocCodeKeywordSpan">UnprocessableEntity</span>();
  translatedError.errors = body;

  next(translatedError);
});
// Convert Mongo validation errors to unprocessable entity errors.
protect.use(function (error, request, response, next) {
  if (!error) return next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnsupportedMediaType" id="apidoc.element.baucis.Error.UnsupportedMediaType">
        function <span class="apidocSignatureSpan">baucis.Error.</span>UnsupportedMediaType
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UnsupportedMediaType = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If so, create a stream from the POST'd document or documents.
if (request.body) {
  pipeline(es.readArray([].concat(request.body)));
}
// Otherwise, stream and parse the request.
else {
  parser = baucis.parser(request.get('content-type'));
  if (!parser) return next(RestError.<span class="apidocCodeKeywordSpan">UnsupportedMediaType</span>());
  pipeline(request);
  pipeline(parser);
}
// Create the stream context.
pipeline(function (incoming, callback) {
  callback(null, { incoming: incoming, doc: null });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.container" id="apidoc.element.baucis.Error.container">
        function <span class="apidocSignatureSpan">baucis.Error.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.decorators" id="apidoc.element.baucis.Error.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.defaults" id="apidoc.element.baucis.Error.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.factory" id="apidoc.element.baucis.Error.factory">
        function <span class="apidocSignatureSpan">baucis.Error.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.inherit" id="apidoc.element.baucis.Error.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.sanitize" id="apidoc.element.baucis.Error.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.status" id="apidoc.element.baucis.Error.status">
        function <span class="apidocSignatureSpan">baucis.Error.</span>status
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">status = function () {
  var args = Array.prototype.slice.call(arguments);
  var status = args.shift();
  var errorNames = Object.keys(RestError).filter(function (name) {
    return RestError[name].status === status;
  });

  if (errorNames.length === 0) {
    throw RestError.Misconfigured('Unknown HTTP status code: %s', status);
  }

  var errorType = RestError[errorNames[0]];

  return errorType.apply(errorType, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
  // Format the error based on the Accept header.
  protect.use(function (error, request, response, next) {
if (!error) return next();

// Always set the status code if available.
if (error.status &gt;= 100) {
  response.<span class="apidocCodeKeywordSpan">status</span>(error.status);
}

if (!controller.handleErrors()) return next(error);

baucis.formatters(response, function (error2, formatter) {
  if (error2) return next(error2);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.super_" id="apidoc.element.baucis.Error.super_">
        function <span class="apidocSignatureSpan">baucis.Error.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.BadRequest" id="apidoc.module.baucis.Error.BadRequest">module baucis.Error.BadRequest</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.BadRequest.BadRequest" id="apidoc.element.baucis.Error.BadRequest.BadRequest">
        function <span class="apidocSignatureSpan">baucis.Error.</span>BadRequest
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BadRequest = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
response.vary('API-Version');
// TODO move this
// Requested range is used to select highest possible release number.
// Then later controllers are checked for matching the release number.
var version = request.headers['api-version'] || '*';
// Check the requested API version is valid.
if (!semver.validRange(version)) {
  next(RestError.<span class="apidocCodeKeywordSpan">BadRequest</span>('The requested API version range "%s" was
not a valid semver range', version));
  return;
}

request.baucis.release = semver.maxSatisfying(api.releases(), version);
// Check for API version unsatisfied and give a 400 if no versions match.
if (!request.baucis.release) {
  next(RestError.BadRequest('The requested API version range "%s" could not be satisfied', version));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadRequest.container" id="apidoc.element.baucis.Error.BadRequest.container">
        function <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadRequest.decorators" id="apidoc.element.baucis.Error.BadRequest.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadRequest.defaults" id="apidoc.element.baucis.Error.BadRequest.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadRequest.factory" id="apidoc.element.baucis.Error.BadRequest.factory">
        function <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadRequest.inherit" id="apidoc.element.baucis.Error.BadRequest.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadRequest.sanitize" id="apidoc.element.baucis.Error.BadRequest.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadRequest.super_" id="apidoc.element.baucis.Error.BadRequest.super_">
        function <span class="apidocSignatureSpan">baucis.Error.BadRequest.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.BadSyntax" id="apidoc.module.baucis.Error.BadSyntax">module baucis.Error.BadSyntax</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.BadSyntax.BadSyntax" id="apidoc.element.baucis.Error.BadSyntax.BadSyntax">
        function <span class="apidocSignatureSpan">baucis.Error.</span>BadSyntax
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">BadSyntax = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadSyntax.container" id="apidoc.element.baucis.Error.BadSyntax.container">
        function <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadSyntax.decorators" id="apidoc.element.baucis.Error.BadSyntax.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadSyntax.defaults" id="apidoc.element.baucis.Error.BadSyntax.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadSyntax.factory" id="apidoc.element.baucis.Error.BadSyntax.factory">
        function <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadSyntax.inherit" id="apidoc.element.baucis.Error.BadSyntax.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadSyntax.sanitize" id="apidoc.element.baucis.Error.BadSyntax.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.BadSyntax.super_" id="apidoc.element.baucis.Error.BadSyntax.super_">
        function <span class="apidocSignatureSpan">baucis.Error.BadSyntax.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.Deprecated" id="apidoc.module.baucis.Error.Deprecated">module baucis.Error.Deprecated</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.Deprecated.Deprecated" id="apidoc.element.baucis.Error.Deprecated.Deprecated">
        function <span class="apidocSignatureSpan">baucis.Error.</span>Deprecated
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Deprecated = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Deprecated.container" id="apidoc.element.baucis.Error.Deprecated.container">
        function <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Deprecated.decorators" id="apidoc.element.baucis.Error.Deprecated.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Deprecated.defaults" id="apidoc.element.baucis.Error.Deprecated.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Deprecated.factory" id="apidoc.element.baucis.Error.Deprecated.factory">
        function <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Deprecated.inherit" id="apidoc.element.baucis.Error.Deprecated.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Deprecated.sanitize" id="apidoc.element.baucis.Error.Deprecated.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Deprecated.super_" id="apidoc.element.baucis.Error.Deprecated.super_">
        function <span class="apidocSignatureSpan">baucis.Error.Deprecated.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.Forbidden" id="apidoc.module.baucis.Error.Forbidden">module baucis.Error.Forbidden</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.Forbidden.Forbidden" id="apidoc.element.baucis.Error.Forbidden.Forbidden">
        function <span class="apidocSignatureSpan">baucis.Error.</span>Forbidden
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Forbidden = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

// Perform distinct query.
this.query(function (request, response, next) {
  var distinct = request.query.distinct;
  if (!distinct) return next();
  if (controller.deselected(distinct)) {
    next(RestError.<span class="apidocCodeKeywordSpan">Forbidden</span>('You may not find distinct values for the requested
 path'));
    return;
  }
  var query = controller.model().distinct(distinct, request.baucis.conditions);
  query.exec(function (error, values) {
    if (error) return next(error);
    request.baucis.documents = values;
    next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Forbidden.container" id="apidoc.element.baucis.Error.Forbidden.container">
        function <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Forbidden.decorators" id="apidoc.element.baucis.Error.Forbidden.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Forbidden.defaults" id="apidoc.element.baucis.Error.Forbidden.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Forbidden.factory" id="apidoc.element.baucis.Error.Forbidden.factory">
        function <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Forbidden.inherit" id="apidoc.element.baucis.Error.Forbidden.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Forbidden.sanitize" id="apidoc.element.baucis.Error.Forbidden.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Forbidden.super_" id="apidoc.element.baucis.Error.Forbidden.super_">
        function <span class="apidocSignatureSpan">baucis.Error.Forbidden.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.Gone" id="apidoc.module.baucis.Error.Gone">module baucis.Error.Gone</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.Gone.Gone" id="apidoc.element.baucis.Error.Gone.Gone">
        function <span class="apidocSignatureSpan">baucis.Error.</span>Gone
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Gone = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Gone.container" id="apidoc.element.baucis.Error.Gone.container">
        function <span class="apidocSignatureSpan">baucis.Error.Gone.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Gone.decorators" id="apidoc.element.baucis.Error.Gone.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.Gone.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Gone.defaults" id="apidoc.element.baucis.Error.Gone.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.Gone.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Gone.factory" id="apidoc.element.baucis.Error.Gone.factory">
        function <span class="apidocSignatureSpan">baucis.Error.Gone.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Gone.inherit" id="apidoc.element.baucis.Error.Gone.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.Gone.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Gone.sanitize" id="apidoc.element.baucis.Error.Gone.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.Gone.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Gone.super_" id="apidoc.element.baucis.Error.Gone.super_">
        function <span class="apidocSignatureSpan">baucis.Error.Gone.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.InternalServerError" id="apidoc.module.baucis.Error.InternalServerError">module baucis.Error.InternalServerError</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.InternalServerError.InternalServerError" id="apidoc.element.baucis.Error.InternalServerError.InternalServerError">
        function <span class="apidocSignatureSpan">baucis.Error.</span>InternalServerError
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">InternalServerError = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!(error instanceof mongoose.Error.VersionError)) return next(error);
  next(RestError.LockConflict());
});
// Translate other errors to internal server errors.
protect.use(function (error, request, response, next) {
  if (!error) return next();
  if (error instanceof RestError) return next(error);
  var error2 = RestError.<span class="apidocCodeKeywordSpan">InternalServerError</span>(error.message);
  error2.stack = error.stack;
  next(error2);
});
// Format the error based on the Accept header.
protect.use(function (error, request, response, next) {
  if (!error) return next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.InternalServerError.container" id="apidoc.element.baucis.Error.InternalServerError.container">
        function <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.InternalServerError.decorators" id="apidoc.element.baucis.Error.InternalServerError.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.InternalServerError.defaults" id="apidoc.element.baucis.Error.InternalServerError.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.InternalServerError.factory" id="apidoc.element.baucis.Error.InternalServerError.factory">
        function <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.InternalServerError.inherit" id="apidoc.element.baucis.Error.InternalServerError.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.InternalServerError.sanitize" id="apidoc.element.baucis.Error.InternalServerError.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.InternalServerError.super_" id="apidoc.element.baucis.Error.InternalServerError.super_">
        function <span class="apidocSignatureSpan">baucis.Error.InternalServerError.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.LengthRequired" id="apidoc.module.baucis.Error.LengthRequired">module baucis.Error.LengthRequired</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.LengthRequired.LengthRequired" id="apidoc.element.baucis.Error.LengthRequired.LengthRequired">
        function <span class="apidocSignatureSpan">baucis.Error.</span>LengthRequired
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LengthRequired = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LengthRequired.container" id="apidoc.element.baucis.Error.LengthRequired.container">
        function <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LengthRequired.decorators" id="apidoc.element.baucis.Error.LengthRequired.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LengthRequired.defaults" id="apidoc.element.baucis.Error.LengthRequired.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LengthRequired.factory" id="apidoc.element.baucis.Error.LengthRequired.factory">
        function <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LengthRequired.inherit" id="apidoc.element.baucis.Error.LengthRequired.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LengthRequired.sanitize" id="apidoc.element.baucis.Error.LengthRequired.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LengthRequired.super_" id="apidoc.element.baucis.Error.LengthRequired.super_">
        function <span class="apidocSignatureSpan">baucis.Error.LengthRequired.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.LockConflict" id="apidoc.module.baucis.Error.LockConflict">module baucis.Error.LockConflict</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.LockConflict.LockConflict" id="apidoc.element.baucis.Error.LockConflict.LockConflict">
        function <span class="apidocSignatureSpan">baucis.Error.</span>LockConflict
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">LockConflict = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  newError.errors = error.errors;
  next(newError);
});
// Convert Mongoose version conflict error to LockConflict.
protect.use(function (error, request, response, next) {
  if (!error) return next();
  if (!(error instanceof mongoose.Error.VersionError)) return next(error);
  next(RestError.<span class="apidocCodeKeywordSpan">LockConflict</span>());
});
// Translate other errors to internal server errors.
protect.use(function (error, request, response, next) {
  if (!error) return next();
  if (error instanceof RestError) return next(error);
  var error2 = RestError.InternalServerError(error.message);
  error2.stack = error.stack;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LockConflict.container" id="apidoc.element.baucis.Error.LockConflict.container">
        function <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LockConflict.decorators" id="apidoc.element.baucis.Error.LockConflict.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LockConflict.defaults" id="apidoc.element.baucis.Error.LockConflict.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LockConflict.factory" id="apidoc.element.baucis.Error.LockConflict.factory">
        function <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LockConflict.inherit" id="apidoc.element.baucis.Error.LockConflict.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LockConflict.sanitize" id="apidoc.element.baucis.Error.LockConflict.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.LockConflict.super_" id="apidoc.element.baucis.Error.LockConflict.super_">
        function <span class="apidocSignatureSpan">baucis.Error.LockConflict.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.MethodNotAllowed" id="apidoc.module.baucis.Error.MethodNotAllowed">module baucis.Error.MethodNotAllowed</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.MethodNotAllowed.MethodNotAllowed" id="apidoc.element.baucis.Error.MethodNotAllowed.MethodNotAllowed">
        function <span class="apidocSignatureSpan">baucis.Error.</span>MethodNotAllowed
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">MethodNotAllowed = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  next(RestError.BadRequest('The requested document ID "%s" is not a valid document ID', id));
});

// Check that the HTTP method has not been disabled for this controller.
controller.request(function (request, response, next) {
  var method = request.method.toLowerCase();
  if (controller.methods(method) !== false) return next();
  next(RestError.<span class="apidocCodeKeywordSpan">MethodNotAllowed</span>('The requested method has been disabled for this
 resource'));
});

// Treat the addressed document as a collection, and push the addressed object
// to it.  (Not implemented.)
controller.request('instance', 'post', function (request, response, next) {
  return next(RestError.NotImplemented('Cannot POST to an instance'));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.MethodNotAllowed.container" id="apidoc.element.baucis.Error.MethodNotAllowed.container">
        function <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.MethodNotAllowed.decorators" id="apidoc.element.baucis.Error.MethodNotAllowed.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.MethodNotAllowed.defaults" id="apidoc.element.baucis.Error.MethodNotAllowed.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.MethodNotAllowed.factory" id="apidoc.element.baucis.Error.MethodNotAllowed.factory">
        function <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.MethodNotAllowed.inherit" id="apidoc.element.baucis.Error.MethodNotAllowed.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.MethodNotAllowed.sanitize" id="apidoc.element.baucis.Error.MethodNotAllowed.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.MethodNotAllowed.super_" id="apidoc.element.baucis.Error.MethodNotAllowed.super_">
        function <span class="apidocSignatureSpan">baucis.Error.MethodNotAllowed.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.Misconfigured" id="apidoc.module.baucis.Error.Misconfigured">module baucis.Error.Misconfigured</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.Misconfigured.Misconfigured" id="apidoc.element.baucis.Error.Misconfigured.Misconfigured">
        function <span class="apidocSignatureSpan">baucis.Error.</span>Misconfigured
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Misconfigured = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var RestError = require('rest-error');

// __Module Definition__
var Api = module.exports = deco(function (options, protect) {
  var api = this;

  api.use(function (request, response, next) {
if (request.baucis) return next(RestError.<span class="apidocCodeKeywordSpan">Misconfigured</span>('Baucis request property
 already created'));

request.baucis = {};
response.removeHeader('x-powered-by');
// Any caching proxies should be aware of API version.
response.vary('API-Version');
// TODO move this
// Requested range is used to select highest possible release number.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Misconfigured.container" id="apidoc.element.baucis.Error.Misconfigured.container">
        function <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Misconfigured.decorators" id="apidoc.element.baucis.Error.Misconfigured.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Misconfigured.defaults" id="apidoc.element.baucis.Error.Misconfigured.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Misconfigured.factory" id="apidoc.element.baucis.Error.Misconfigured.factory">
        function <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Misconfigured.inherit" id="apidoc.element.baucis.Error.Misconfigured.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Misconfigured.sanitize" id="apidoc.element.baucis.Error.Misconfigured.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Misconfigured.super_" id="apidoc.element.baucis.Error.Misconfigured.super_">
        function <span class="apidocSignatureSpan">baucis.Error.Misconfigured.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.NotAcceptable" id="apidoc.module.baucis.Error.NotAcceptable">module baucis.Error.NotAcceptable</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.NotAcceptable.NotAcceptable" id="apidoc.element.baucis.Error.NotAcceptable.NotAcceptable">
        function <span class="apidocSignatureSpan">baucis.Error.</span>NotAcceptable
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotAcceptable = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
//     });
//   });
//   return;
// }

var handlers = {
  default: function () {
    callback(RestError.<span class="apidocCodeKeywordSpan">NotAcceptable</span>());
  }
};

Object.keys(formatters).map(function (mime) {
  handlers[mime] = formatters[mime](callback);
});
response.format(handlers);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotAcceptable.container" id="apidoc.element.baucis.Error.NotAcceptable.container">
        function <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotAcceptable.decorators" id="apidoc.element.baucis.Error.NotAcceptable.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotAcceptable.defaults" id="apidoc.element.baucis.Error.NotAcceptable.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotAcceptable.factory" id="apidoc.element.baucis.Error.NotAcceptable.factory">
        function <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotAcceptable.inherit" id="apidoc.element.baucis.Error.NotAcceptable.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotAcceptable.sanitize" id="apidoc.element.baucis.Error.NotAcceptable.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotAcceptable.super_" id="apidoc.element.baucis.Error.NotAcceptable.super_">
        function <span class="apidocSignatureSpan">baucis.Error.NotAcceptable.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.NotFound" id="apidoc.module.baucis.Error.NotFound">module baucis.Error.NotFound</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.NotFound.NotFound" id="apidoc.element.baucis.Error.NotFound.NotFound">
        function <span class="apidocSignatureSpan">baucis.Error.</span>NotFound
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotFound = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (status === 200) {
      response.removeHeader('Transfer-Encoding');
      response.json([]); // TODO other content types
      this.emit('end');
      return;
    }

    this.emit('error', RestError.<span class="apidocCodeKeywordSpan">NotFound</span>());
  }
));
// Apply user streams.
pipeline(request.baucis.outgoing());

// Set the document formatter based on the Accept header of the request.
baucis.formatters(response, function (error, formatter) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotFound.container" id="apidoc.element.baucis.Error.NotFound.container">
        function <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotFound.decorators" id="apidoc.element.baucis.Error.NotFound.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotFound.defaults" id="apidoc.element.baucis.Error.NotFound.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotFound.factory" id="apidoc.element.baucis.Error.NotFound.factory">
        function <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotFound.inherit" id="apidoc.element.baucis.Error.NotFound.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotFound.sanitize" id="apidoc.element.baucis.Error.NotFound.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotFound.super_" id="apidoc.element.baucis.Error.NotFound.super_">
        function <span class="apidocSignatureSpan">baucis.Error.NotFound.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.NotImplemented" id="apidoc.module.baucis.Error.NotImplemented">module baucis.Error.NotImplemented</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.NotImplemented.NotImplemented" id="apidoc.element.baucis.Error.NotImplemented.NotImplemented">
        function <span class="apidocSignatureSpan">baucis.Error.</span>NotImplemented
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">NotImplemented = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    // Finish up for a non-default update operator (bypasses validation).
    else {
      pipeline(function (context, callback) {
var wrapper = {};

if (validOperators.indexOf(operator) === -1) {
  callback(RestError.<span class="apidocCodeKeywordSpan">NotImplemented</span>('The requested update operator "%s"
; is not supported', operator));
  return;
}
// Ensure that some paths have been enabled for the operator.
if (!controller.operators(operator)) {
  callback(RestError.Forbidden('The requested update operator "%s" is not enabled for this resource', operator
));
  return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotImplemented.container" id="apidoc.element.baucis.Error.NotImplemented.container">
        function <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotImplemented.decorators" id="apidoc.element.baucis.Error.NotImplemented.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotImplemented.defaults" id="apidoc.element.baucis.Error.NotImplemented.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotImplemented.factory" id="apidoc.element.baucis.Error.NotImplemented.factory">
        function <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotImplemented.inherit" id="apidoc.element.baucis.Error.NotImplemented.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotImplemented.sanitize" id="apidoc.element.baucis.Error.NotImplemented.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.NotImplemented.super_" id="apidoc.element.baucis.Error.NotImplemented.super_">
        function <span class="apidocSignatureSpan">baucis.Error.NotImplemented.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.PreconditionFailed" id="apidoc.module.baucis.Error.PreconditionFailed">module baucis.Error.PreconditionFailed</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.PreconditionFailed.PreconditionFailed" id="apidoc.element.baucis.Error.PreconditionFailed.PreconditionFailed">
        function <span class="apidocSignatureSpan">baucis.Error.</span>PreconditionFailed
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">PreconditionFailed = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.PreconditionFailed.container" id="apidoc.element.baucis.Error.PreconditionFailed.container">
        function <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.PreconditionFailed.decorators" id="apidoc.element.baucis.Error.PreconditionFailed.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.PreconditionFailed.defaults" id="apidoc.element.baucis.Error.PreconditionFailed.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.PreconditionFailed.factory" id="apidoc.element.baucis.Error.PreconditionFailed.factory">
        function <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.PreconditionFailed.inherit" id="apidoc.element.baucis.Error.PreconditionFailed.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.PreconditionFailed.sanitize" id="apidoc.element.baucis.Error.PreconditionFailed.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.PreconditionFailed.super_" id="apidoc.element.baucis.Error.PreconditionFailed.super_">
        function <span class="apidocSignatureSpan">baucis.Error.PreconditionFailed.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.RequestEntityTooLarge" id="apidoc.module.baucis.Error.RequestEntityTooLarge">module baucis.Error.RequestEntityTooLarge</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.RequestEntityTooLarge.RequestEntityTooLarge" id="apidoc.element.baucis.Error.RequestEntityTooLarge.RequestEntityTooLarge">
        function <span class="apidocSignatureSpan">baucis.Error.</span>RequestEntityTooLarge
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RequestEntityTooLarge = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestEntityTooLarge.container" id="apidoc.element.baucis.Error.RequestEntityTooLarge.container">
        function <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestEntityTooLarge.decorators" id="apidoc.element.baucis.Error.RequestEntityTooLarge.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestEntityTooLarge.defaults" id="apidoc.element.baucis.Error.RequestEntityTooLarge.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestEntityTooLarge.factory" id="apidoc.element.baucis.Error.RequestEntityTooLarge.factory">
        function <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestEntityTooLarge.inherit" id="apidoc.element.baucis.Error.RequestEntityTooLarge.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestEntityTooLarge.sanitize" id="apidoc.element.baucis.Error.RequestEntityTooLarge.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestEntityTooLarge.super_" id="apidoc.element.baucis.Error.RequestEntityTooLarge.super_">
        function <span class="apidocSignatureSpan">baucis.Error.RequestEntityTooLarge.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.RequestUriTooLong" id="apidoc.module.baucis.Error.RequestUriTooLong">module baucis.Error.RequestUriTooLong</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.RequestUriTooLong.RequestUriTooLong" id="apidoc.element.baucis.Error.RequestUriTooLong.RequestUriTooLong">
        function <span class="apidocSignatureSpan">baucis.Error.</span>RequestUriTooLong
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">RequestUriTooLong = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestUriTooLong.container" id="apidoc.element.baucis.Error.RequestUriTooLong.container">
        function <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestUriTooLong.decorators" id="apidoc.element.baucis.Error.RequestUriTooLong.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestUriTooLong.defaults" id="apidoc.element.baucis.Error.RequestUriTooLong.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestUriTooLong.factory" id="apidoc.element.baucis.Error.RequestUriTooLong.factory">
        function <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestUriTooLong.inherit" id="apidoc.element.baucis.Error.RequestUriTooLong.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestUriTooLong.sanitize" id="apidoc.element.baucis.Error.RequestUriTooLong.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.RequestUriTooLong.super_" id="apidoc.element.baucis.Error.RequestUriTooLong.super_">
        function <span class="apidocSignatureSpan">baucis.Error.RequestUriTooLong.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.Teapot" id="apidoc.module.baucis.Error.Teapot">module baucis.Error.Teapot</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.Teapot.Teapot" id="apidoc.element.baucis.Error.Teapot.Teapot">
        function <span class="apidocSignatureSpan">baucis.Error.</span>Teapot
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Teapot = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Teapot.container" id="apidoc.element.baucis.Error.Teapot.container">
        function <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Teapot.decorators" id="apidoc.element.baucis.Error.Teapot.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Teapot.defaults" id="apidoc.element.baucis.Error.Teapot.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Teapot.factory" id="apidoc.element.baucis.Error.Teapot.factory">
        function <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Teapot.inherit" id="apidoc.element.baucis.Error.Teapot.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Teapot.sanitize" id="apidoc.element.baucis.Error.Teapot.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Teapot.super_" id="apidoc.element.baucis.Error.Teapot.super_">
        function <span class="apidocSignatureSpan">baucis.Error.Teapot.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.TooManyRequests" id="apidoc.module.baucis.Error.TooManyRequests">module baucis.Error.TooManyRequests</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.TooManyRequests.TooManyRequests" id="apidoc.element.baucis.Error.TooManyRequests.TooManyRequests">
        function <span class="apidocSignatureSpan">baucis.Error.</span>TooManyRequests
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">TooManyRequests = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.TooManyRequests.container" id="apidoc.element.baucis.Error.TooManyRequests.container">
        function <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.TooManyRequests.decorators" id="apidoc.element.baucis.Error.TooManyRequests.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.TooManyRequests.defaults" id="apidoc.element.baucis.Error.TooManyRequests.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.TooManyRequests.factory" id="apidoc.element.baucis.Error.TooManyRequests.factory">
        function <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.TooManyRequests.inherit" id="apidoc.element.baucis.Error.TooManyRequests.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.TooManyRequests.sanitize" id="apidoc.element.baucis.Error.TooManyRequests.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.TooManyRequests.super_" id="apidoc.element.baucis.Error.TooManyRequests.super_">
        function <span class="apidocSignatureSpan">baucis.Error.TooManyRequests.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.Unauthorized" id="apidoc.module.baucis.Error.Unauthorized">module baucis.Error.Unauthorized</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.Unauthorized.Unauthorized" id="apidoc.element.baucis.Error.Unauthorized.Unauthorized">
        function <span class="apidocSignatureSpan">baucis.Error.</span>Unauthorized
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Unauthorized = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Unauthorized.container" id="apidoc.element.baucis.Error.Unauthorized.container">
        function <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Unauthorized.decorators" id="apidoc.element.baucis.Error.Unauthorized.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Unauthorized.defaults" id="apidoc.element.baucis.Error.Unauthorized.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Unauthorized.factory" id="apidoc.element.baucis.Error.Unauthorized.factory">
        function <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Unauthorized.inherit" id="apidoc.element.baucis.Error.Unauthorized.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Unauthorized.sanitize" id="apidoc.element.baucis.Error.Unauthorized.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.Unauthorized.super_" id="apidoc.element.baucis.Error.Unauthorized.super_">
        function <span class="apidocSignatureSpan">baucis.Error.Unauthorized.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.UnprocessableEntity" id="apidoc.module.baucis.Error.UnprocessableEntity">module baucis.Error.UnprocessableEntity</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.UnprocessableEntity.UnprocessableEntity" id="apidoc.element.baucis.Error.UnprocessableEntity.UnprocessableEntity">
        function <span class="apidocSignatureSpan">baucis.Error.</span>UnprocessableEntity
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UnprocessableEntity = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    originalMessage: error.message,
    name: 'MongoError',
    path: path,
    type: 'unique',
    value: value
  };

  var translatedError = RestError.<span class="apidocCodeKeywordSpan">UnprocessableEntity</span>();
  translatedError.errors = body;

  next(translatedError);
});
// Convert Mongo validation errors to unprocessable entity errors.
protect.use(function (error, request, response, next) {
  if (!error) return next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnprocessableEntity.container" id="apidoc.element.baucis.Error.UnprocessableEntity.container">
        function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnprocessableEntity.decorators" id="apidoc.element.baucis.Error.UnprocessableEntity.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnprocessableEntity.defaults" id="apidoc.element.baucis.Error.UnprocessableEntity.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnprocessableEntity.factory" id="apidoc.element.baucis.Error.UnprocessableEntity.factory">
        function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnprocessableEntity.inherit" id="apidoc.element.baucis.Error.UnprocessableEntity.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnprocessableEntity.sanitize" id="apidoc.element.baucis.Error.UnprocessableEntity.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnprocessableEntity.super_" id="apidoc.element.baucis.Error.UnprocessableEntity.super_">
        function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.UnprocessableEntity.prototype" id="apidoc.module.baucis.Error.UnprocessableEntity.prototype">module baucis.Error.UnprocessableEntity.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.UnprocessableEntity.prototype.add" id="apidoc.element.baucis.Error.UnprocessableEntity.prototype.add">
        function <span class="apidocSignatureSpan">baucis.Error.UnprocessableEntity.prototype.</span>add
        <span class="apidocSignatureSpan">(key, error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (key, error) {
  this.errors.push(error);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      throw RestError.Misconfigured('Release version "%s" is not a valid semver version', release);
    }
    return this.releases().concat(release);
  });

  api.rest = function (model) {
    var controller = Controller(model);
    api.<span class="apidocCodeKeywordSpan">add</span>(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.UnsupportedMediaType" id="apidoc.module.baucis.Error.UnsupportedMediaType">module baucis.Error.UnsupportedMediaType</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.UnsupportedMediaType.UnsupportedMediaType" id="apidoc.element.baucis.Error.UnsupportedMediaType.UnsupportedMediaType">
        function <span class="apidocSignatureSpan">baucis.Error.</span>UnsupportedMediaType
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">UnsupportedMediaType = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If so, create a stream from the POST'd document or documents.
if (request.body) {
  pipeline(es.readArray([].concat(request.body)));
}
// Otherwise, stream and parse the request.
else {
  parser = baucis.parser(request.get('content-type'));
  if (!parser) return next(RestError.<span class="apidocCodeKeywordSpan">UnsupportedMediaType</span>());
  pipeline(request);
  pipeline(parser);
}
// Create the stream context.
pipeline(function (incoming, callback) {
  callback(null, { incoming: incoming, doc: null });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnsupportedMediaType.container" id="apidoc.element.baucis.Error.UnsupportedMediaType.container">
        function <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnsupportedMediaType.decorators" id="apidoc.element.baucis.Error.UnsupportedMediaType.decorators">
        function <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnsupportedMediaType.defaults" id="apidoc.element.baucis.Error.UnsupportedMediaType.defaults">
        function <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnsupportedMediaType.factory" id="apidoc.element.baucis.Error.UnsupportedMediaType.factory">
        function <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnsupportedMediaType.inherit" id="apidoc.element.baucis.Error.UnsupportedMediaType.inherit">
        function <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnsupportedMediaType.sanitize" id="apidoc.element.baucis.Error.UnsupportedMediaType.sanitize">
        function <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.UnsupportedMediaType.super_" id="apidoc.element.baucis.Error.UnsupportedMediaType.super_">
        function <span class="apidocSignatureSpan">baucis.Error.UnsupportedMediaType.</span>super_
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">super_ = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Error.super_" id="apidoc.module.baucis.Error.super_">module baucis.Error.super_</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Error.super_.super_" id="apidoc.element.baucis.Error.super_.super_">
        function <span class="apidocSignatureSpan">baucis.Error.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Error.super_.captureStackTrace" id="apidoc.element.baucis.Error.super_.captureStackTrace">
        function <span class="apidocSignatureSpan">baucis.Error.super_.</span>captureStackTrace
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function captureStackTrace() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.baucis.Model" id="apidoc.module.baucis.Model">module baucis.Model</a></h1>


    <h2>
        <a href="#apidoc.element.baucis.Model.Model" id="apidoc.element.baucis.Model.Model">
        function <span class="apidocSignatureSpan">baucis.</span>Model
        <span class="apidocSignatureSpan">(incoming, protect)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Model = function (incoming, protect) {
  // The object to be decorated.
  var o;
  // Incoming constructor options merged with defaults.
  var merged;
  // Constructor options that have been overwritten by a decorator.
  var overwritten;
  // Store values of properties.
  var properties = {};
  // Store values of multiproperties.
  var multi = {};
  // If `this`, the object to be decorated, has already been set it means
  // the object that is being decorated is already created. (It will be set to
  // `global` if not, thus creating the danger associated with the `new`
  // keyword, and its accidental omission.)
  if (this !== global &amp;&amp; this !== internal.container) o = this;
  // If it hasn't been set yet, check for a factory function.
  else if (internal.factory) o = internal.factory(arguments);
  // Otherwise, construct the object to be decorated.
  else o = Object.create(Constructor.prototype);
  // Allow clean up of arguments, so that initial constructor call can be anything.
  if (internal.sanitize) {
    incoming = internal.sanitize.apply(undefined, arguments);
    protect = undefined;
  }
  // Default protected instance values.
  if (!protect) {
    protect = {
      options: function (newOptions) {
        overwritten = deco.merge(overwritten || defaults, newOptions);
      },
      property: function (name, initial, f) {
        function getter () {
          // Getter with transform.
          if (typeof initial === 'function') {
            return initial.bind(o)(properties[name]);
          }
          // Vanilla getter.
          return properties[name] === undefined ? initial : properties[name];
        }
        function setter (value) {
          if (f) properties[name] = f.bind(o)(value);
          else properties[name] = value;
          return o;
        }
        // Can't redefine properties.
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Set the initial value.
        if (typeof initial !== 'function') properties[name] = initial;
        // Define the property.
        o[name] = function (value) {
          if (arguments.length === 1) return setter(value);
          return getter();
        };
      },

      // o.name('a b c', val) -&gt; store[a,b,c] = val;
      // o.name('a') -&gt; store[a];
      // o.name() -&gt; ['a', 'b']; // active ones
      multiproperty: function (name, keys, initial, action) {
        var store = multi[name] = {};
        if (o[name]) {
          throw new Error('A property with the name "' + name + "' was already added to this object.")
        }
        // Add the property to the controller.
        var f = o[name] = function (items, cargo) {
          // get the stores value
          function getter (key) {
            if (key.match(/\s/)) throw new Error('Can only specify one item when getting');
            var r = store[key];
            if (r === undefined) return initial;
            return r;
          }
          function setter () {
            items.split(/\s+/g).filter(function (v) { return v }).forEach(function (item) {
              store[item] = action ? action(cargo) : cargo;
            });
            return o;
          }
          // If one argument was passed, return the value for that item.
          if (arguments.length === 1) return getter(items);
          // If two arguments were passed, update the items with the cargo.
          else if (arguments.length === 2) return setter();
          // Otherwise, return a list of defined items.
          else return Object.keys(store).filter(getter);
        };

        if (keys) f(keys, initial);
        return o;
      }
    };
  }
  // Initialize the incoming constructor options, if necessary.
  if (incoming === undefined || incoming === null) incoming = {};
  // Merge the incoming options with any defaults, if they're a hash.
  if (typeof incoming === 'object') merged = deco.merge(defaults, incoming);
  // If the constructor inherits, call the super constructor on the object
  // to be decorated.
  if (Constructor.super ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Model.container" id="apidoc.element.baucis.Model.container">
        function <span class="apidocSignatureSpan">baucis.Model.</span>container
        <span class="apidocSignatureSpan">(container)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">container = function (container) {
  internal.container = container;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// __Expose Modules__
baucis.Api = Api;
baucis.Controller = Controller;
baucis.Error = RestError;
baucis.Model = Model;

Api.<span class="apidocCodeKeywordSpan">container</span>(baucis);
Controller.container(baucis);
RestError.container(baucis);
Model.container(baucis);

// __Plugins__
plugins.json.apply(baucis);
plugins.links.apply(baucis);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Model.decorators" id="apidoc.element.baucis.Model.decorators">
        function <span class="apidocSignatureSpan">baucis.Model.</span>decorators
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorators = function () {
  decorators = decorators.concat(parse(arguments));
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.factory(express.Router);
Api.<span class="apidocCodeKeywordSpan">decorators</span>(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Model.defaults" id="apidoc.element.baucis.Model.defaults">
        function <span class="apidocSignatureSpan">baucis.Model.</span>defaults
        <span class="apidocSignatureSpan">(incoming)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaults = function (incoming) {
  defaults = deco.merge(defaults, incoming);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


var expect = require('expect.js');
var mongoose = require('mongoose');
var express = require('express');
var passport = require('passport')
var LocalStrategy = require('passport-local').Strategy;
var request = require('request').<span class="apidocCodeKeywordSpan">defaults</span>({ json: true });
var baucis = require('..');

var fixtures = require('./fixtures');

describe('Controllers', function () {
before(fixtures.controller.init);
beforeEach(fixtures.controller.create);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Model.factory" id="apidoc.element.baucis.Model.factory">
        function <span class="apidocSignatureSpan">baucis.Model.</span>factory
        <span class="apidocSignatureSpan">(factory)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">factory = function (factory) {
  internal.factory = factory;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  api.rest = function (model) {
    var controller = Controller(model);
    api.add(controller);
    return controller;
  };
});

Api.<span class="apidocCodeKeywordSpan">factory</span>(express.Router);
Api.decorators(__dirname, ['controllers']);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Model.inherit" id="apidoc.element.baucis.Model.inherit">
        function <span class="apidocSignatureSpan">baucis.Model.</span>inherit
        <span class="apidocSignatureSpan">(super_)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inherit = function (super_) {
  util.inherits(Constructor, super_);
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var app;
var server;

var BaseSchema = deco(function () {
  this.add({ name: String });
});

BaseSchema.<span class="apidocCodeKeywordSpan">inherit</span>(mongoose.Schema);

var LiqueurSchema = BaseSchema();
var AmaroSchema = BaseSchema({ bitterness: Number });
var CordialSchema = BaseSchema({ sweetness: Number });

var Liqueur = mongoose.model('liqueur', LiqueurSchema);
var Amaro = Liqueur.discriminator('amaro', AmaroSchema).plural('amari');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.baucis.Model.sanitize" id="apidoc.element.baucis.Model.sanitize">
        function <span class="apidocSignatureSpan">baucis.Model.</span>sanitize
        <span class="apidocSignatureSpan">(f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sanitize = function (f) {
  internal.sanitize = f;
  return Constructor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>